# -*- coding: utf-8 -*-
"""ML Assignment1_3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1flPGOG0Pm2hYsTxCa6C1dhVbneePGwFm
"""
import sys
import numpy as np
import pandas as pd
print(sys.argv)

url = sys.argv[1]+'/X.csv'
# url = 'https://raw.githubusercontent.com/RealGagandeep/DataSet-for-ML/main/data/q3/logisticX.csv'
data = pd.read_csv(url)
arr1 = pd.DataFrame(data)
x = np.array(arr1)

url = sys.argv[2]+'/Y.csv'
# url = 'https://raw.githubusercontent.com/RealGagandeep/DataSet-for-ML/main/data/q3/logisticY.csv'
data = pd.read_csv(url)
arr2 = pd.DataFrame(data)
y = np.array(arr2)


url = sys.argv[3]+'/X.csv'
# url = 'https://raw.githubusercontent.com/RealGagandeep/DataSet-for-ML/main/data/q3/X.csv'
data = pd.read_csv(url)
arr2 = pd.DataFrame(data)
xValidation = np.array(arr2)



def sigmoid(yPredict):                              # Returns a sigmoid array and takes one argument as array
  arr = []
  for i in range(len(yPredict)):
    arr.append((1/(1 + np.exp(-yPredict[i]))))
  return arr

def appendarr(a,b,c):                             # Returns a 2D array with 3 rows takes 3 arguments
  l = []
  l.append(a)
  l.append(b)
  l.append(c)
  return l

x1 = (x[:,0]-np.mean(x[:,0]))/np.std(x[:,0])      # importing data, normalizing it and storing it in x1
x2 = (x[:,1]-np.mean(x[:,1]))/np.std(x[:,1])      # importing data, normalizing it and storing it in x2
xTest1 = (xValidation[:,0]-np.mean(xValidation[:,0]))/np.std(xValidation[:,0])
xTest2 = (xValidation[:,1]-np.mean(xValidation[:,1]))/np.std(xValidation[:,1])

x0 = np.array([1]*len(x1))                        # initializing the x0 array as all 1
eta = .001
weight0 = 0                                       # Initial weight0(OR thet0) value 
weight1 = 0                                       # Initial weight1(OR thet1) value 
weight2 = 0                                       # Initial weight2(OR thet2) value 
stoppingCriteria = 6*10**-3

def g(x0,x1,x2):                                  #Returns sigmoid array of hypotheis function
  hypo = []
  for i in range(len(x1)):
    hypo.append(weight0*x0[i] + weight1*x1[i] + weight2*x2[i])
  return np.array(sigmoid(hypo))

def W(x1,x2):                                     #Returns an array of h0*(1-h0)

  m = (g(x0,x1,x2))
  arr = [ [0]*len(x1) for _ in range(len(x2)) ] 
  for i in range(len(x1)):
    value = m[i]*(1 - m[i])
    arr[i][i] = value
  return arr


def Hessian(X,hh0):                              # Returns Hessian matrix
  val = X@hh0
  ans = val@X.T
  return ans

hh0 = W(x1,x2)                                  # Assigning value of W(x1,x2) to hh0

X = appendarr(x0,x1,x2)                         # Appending the 1D array(s) to X
X = np.array(X)                                 # Converting it to array

updationVal = 1                                 # Updational val (it is the stopping condition)
while(updationVal>stoppingCriteria):            

  y = y.flatten()

  weight0 = (x0@(-(y - g(x0,x1,x2))))/len(x0)
  weight1 = (x1@(-(y - g(x0,x1,x2))))/len(x1)        
  weight2 = (x2@(-(y - g(x0,x1,x2))))/len(x2)
  
  gradient = appendarr(weight0,weight1,weight2)

  # print(Hessian(X,hh0))
  inverse = np.linalg.inv(Hessian(X,hh0))
  
  weight = appendarr(weight0,weight1,weight2)

  weight = np.array(weight)

  weight = weight - eta*inverse@(gradient)        # calculating weights using Newton's method

  updationVal = np.mean(inverse@(gradient))       # calculating mean of change in updation value
  #print(f'weight{np.shape(weight)}')


xTest0 = [1]*len(xTest1)
TestData = []
TestData = appendarr(xTest0,xTest1,xTest2)
z = weight@TestData
yOutput = []
yValidation = 1/(1+np.exp(z))
for i in yValidation:
  if i>.5:
    yOutput.append(1)
  else:
    yOutput.append(0)

print(f'the weights theta0, theta1, theta2 are : {weight}\n And the Validation(Test) data is {(np.array(yOutput))}')
with open("result_3.txt", "a") as f:
  print(f'the weights theta0, theta1, theta2 are : {weight}\n And the Validation(Test) data is {(np.array(yOutput))} ', file=f)


# import matplotlib.pyplot as plt


# x = x1[:50]
# y = x2[:50]

# plt.scatter(x, y, c='green')

# x = x1[50:]
# y = x2[50:]

# plt.scatter(x, y, c='red')

# x = x1
# y = -(weight0/weight2 + weight1*x1/weight2)               # Defining the predicted hypothesis function
# plt.plot(x,y,c='black')                                   # Plotting the predicted hypothesis function


# plt.show()
